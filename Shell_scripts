Linux enviroument:  uname -a
Linux localhost 2.6.18-308.4.1.el5xen #1 SMP Tue Apr 17 18:27:35 EDT 2012 i686 i686 i386 GNU/Linux

1. Redirect file discriptor of the script file: temporary vs permanently redirection. temporary - regular commands, permanently - exec command.
> exec 2>log.err # Permanently redirect standard error discriptor to log.err in current shell
> grep "$test" ./* 2>/dev/null #redirects standard error discriptor temporarily to /dev/null
  
2. 'end of file' vs 'no data available right now': in the pipeline, 'end of file' happens to the after command when the front command terminated, otherwise 'no data available right now'.
> sh -c 'sleep 5' | ( date; cat; date)
Wed Jan 14 05:33:37 CST 
Wed Jan 14 05:33:42 CST 
where cat got 'end of file' after 5 seconds. The 'end of file' is the file discriptor closed, exec redirection also does it.

 (echo "test" 2>/dev/null >&2 ;  echo "test again" 2>/dev/null) | (date;cat;date)
Wed Jan 14 07:37:12 CST 
test again #from stdin
Wed Jan 14 07:37:12 CST 

Where redirect >&2 did not affect following command's standard output file discriptor (temporary);

 (exec 3>&1; exec >/tmp/stdout; echo "test again" ) | (date;cat;date) 2>/dev/null
Wed Jan 14 12:07:46 CST 2015
Wed Jan 14 12:07:46 CST 2015
Where exec >/tmp/stdout redirect stdout to the file (permanently in sub shell that command grouped with parentheses[()])
 {echo "test" 2>/dev/null >&2 ;  exec 3>&1; exec >/tmp/stdout; echo "test again" } | (date;cat;date) 2>/dev/null
Where stdout redirection also used after the pipe because the redirection is in current shell by using braces [{}] grouping the commands.
 (echo "test" 2>/dev/null >&2 ;  exec 3>&1; exec >/tmp/stdout; echo "test again"; exec >&3; echo "my test" ) | (date;cat;date) 2>/dev/null
Wed Jan 14 07:59:58 CST 
my test
Wed Jan 14 07:59:58 CST 

3. how to tell shell commands from shell external utility binary commands - anything you may find in /bin. e.g. true is not shell command but : is. It is important for writing portable shell scripts.

4. Here Document:a) hyphen after << tells shell to strip leading tabs (but not leading spaces); b) if the sentinel is quoted, the input in Here Document like single quoted - no substitutions are performed on the text. 

5.tokenize - maximal munch: (Tokens - word, keyword, special charactors)
 echo a #b;echo c# d e
a
 echo a #b
a
 echo c# d e
c# d e

Cannot expand variables into special kokens - only plain words. the results of substitution, globbing, or quoting are always words.

 str="X=3"
 $str
-bash: X=3: command not found
 eval $str; echo $X
3

keywords: ! { } case do done elif else esac fi for if in then while until

command lists - command list can be endded with a special keyword. the command list exist status is the last command existing status.
  while if true; then false; fi do false;done
  echo $?
 0
 where fi ends the command list of while.
  while true do false; break;done;
-bash: syntax error near unexpected token `done'
where command list of while does not end. 
 while true; do false; break;done;
 echo $?
0
Where ';' ends the command list of while.

short circuits : if exit condition can be determined the cmd2 can be skipped.
cmd1 && cmd2 # both true is true otherwise false
cmd1 || cmd2 # either true is true, both false is false.
so that if cmd1 is false then cmd2 after && will be skipped; in the other side cmd2 after || will be executed.
        if cmd1 is true the cmd2 after && will not be skipped and cmd2 after || will be skipped
