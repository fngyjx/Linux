
Linux enviroument:  uname -a
Linux localhost 2.6.18-308.4.1.el5xen #1 SMP Tue Apr 17 18:27:35 EDT 2012 i686 i686 i386 GNU/Linux

1. Redirect file discriptor of the script file: temporary vs permanently redirection. temporary - regular commands, permanently - exec command.
> exec 2>log.err # Permanently redirect standard error discriptor to log.err in current shell
> grep "$test" ./* 2>/dev/null #redirects standard error discriptor temporarily to /dev/null
  
2. 'end of file' vs 'no data available right now': in the pipeline, 'end of file' happens to the after command when the front command terminated, otherwise 'no data available right now'.
> sh -c 'sleep 5' | ( date; cat; date)
Wed Jan 14 05:33:37 CST 
Wed Jan 14 05:33:42 CST 
where cat got 'end of file' after 5 seconds. The 'end of file' is the file discriptor closed, exec redirection also does it.

 (echo "test" 2>/dev/null >&2 ;  echo "test again" 2>/dev/null) | (date;cat;date)
Wed Jan 14 07:37:12 CST 
test again #from stdin
Wed Jan 14 07:37:12 CST 

Where redirect >&2 did not affect following command's standard output file discriptor (temporary);

 (exec 3>&1; exec >/tmp/stdout; echo "test again" ) | (date;cat;date) 2>/dev/null
Wed Jan 14 12:07:46 CST 2015
Wed Jan 14 12:07:46 CST 2015
Where exec >/tmp/stdout redirect stdout to the file (permanently in sub shell that command grouped with parentheses[()])
 {echo "test" 2>/dev/null >&2 ;  exec 3>&1; exec >/tmp/stdout; echo "test again" } | (date;cat;date) 2>/dev/null
Where stdout redirection also used after the pipe because the redirection is in current shell by using braces [{}] grouping the commands.
 (echo "test" 2>/dev/null >&2 ;  exec 3>&1; exec >/tmp/stdout; echo "test again"; exec >&3; echo "my test" ) | (date;cat;date) 2>/dev/null
Wed Jan 14 07:59:58 CST 
my test
Wed Jan 14 07:59:58 CST 

subshell usually more computationally expensive than compound statements. change () to {} when possible.

3. how to tell shell commands from shell external utility binary commands - anything you may find in /bin. e.g. true is not shell command but : is. It is important for writing portable shell scripts.

4. Here Document:a) hyphen after << tells shell to strip leading tabs (but not leading spaces); b) if the sentinel is quoted, the input in Here Document like single quoted - no substitutions are performed on the text. 

5.tokenize - maximal munch: (Tokens - word, keyword, special charactors)
 echo a #b;echo c# d e
a
 echo a #b
a
 echo c# d e
c# d e

Cannot expand variables into special kokens - only plain words. the results of substitution, globbing, or quoting are always words.

 str="X=3"
 $str
-bash: X=3: command not found
 eval $str; echo $X
3

keywords: ! { } case do done elif else esac fi for if in then while until

command lists - command list can be endded with a special keyword. the command list exist status is the last command existing status.
  while if true; then false; fi do false;done
  echo $?
 0
 where fi ends the command list of while.
  while true do false; break;done;
-bash: syntax error near unexpected token `done'
where command list of while does not end. 
 while true; do false; break;done;
 echo $?
0
Where ';' ends the command list of while.

short circuits : if exit condition can be determined the cmd2 can be skipped.
cmd1 && cmd2 # both true is true otherwise false
cmd1 || cmd2 # either true is true, both false is false.
so that if cmd1 is false then cmd2 after && will be skipped; in the other side cmd2 after || will be executed.
        if cmd1 is true the cmd2 after && will not be skipped and cmd2 after || will be skipped

Use external shell to start a completely independent (to parent) background task.

sh -c "back_ground_task >/dev/null 2>&1 </dev/null &"

The standard I/O redirection is important, cus the parent process may have I/O stream opened when the back ground process is started to preent they are closed when the back ground task exits.

sh -c "tar cf - $dir | bizp2 | ssh user@remote \"bzip2 -dc | tar xf -\" &"

tar cf - . | (cd $target_dir; tar xpf -)

tar unlike cp command, it preserves a broad varity of nonstatandard files, such as device nodes.

md5sum Shell_scripts
 80dcfb33778ff19dae3a8777e4722c5e Shell_scripts

command substitute:
var=`md5sum Shell_scripts`; echo "var=["$var"]"
 var=[80dcfb33778ff19dae3a8777e4722c5e Shell_scripts]

Pipe redirection

md5sum Shell_scripts | read var; echo "var=["$var"]"
 var=[]

md5sum Shell_scripts | ( read var; echo "var=["$var"]"
 var=[80dcfb33778ff19dae3a8777e4722c5e Shell_scripts]

md5sum Shell_scripts 2>/dev/null | (read var var1; echo "var=["$var"] var1=["$var1"]")
 var=[80dcfb33778ff19dae3a8777e4722c5e] var1=[Shell_scripts]

md5sum Shell_scripts 2>/dev/null | while read var
do
echo "var=["$var"]"
done
 var=[80dcfb33778ff19dae3a8777e4722c5e Shell_scripts]

#!/bin/sh  #ELF - executable and linking format (#! called as shebang- short for sharp-bang)
